#[macro_use]
extern crate rocket;
#[macro_use]
extern crate serde_derive;
extern crate serde;
extern crate reqwest;
extern crate web3;
extern crate tokio;

// Import the necessary traits and types for serializing and deserializing structs and making HTTP requests
use serde::{Serialize, Deserialize};
use serde_derive::{Serialize, Deserialize};
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::prelude::*;
use reqwest::{Client, Response};

// Import the necessary types for validating and sanitizing input
use std::net::ToSocketAddrs;
use std::str::FromStr;


use rocket::{Form, Redirect, Template};



// Define a struct for representing a saffron order
#[derive(Serialize, Deserialize, Debug)]
struct SaffronOrder {
    // Number of saffron tokens being redeemed
    x: u64,
    // Mail address provided by the user
    mail_address: String,
    // Ascending 8-digit number generated by gen_order_number
    order_number: u64,
}

// Asynchronously prompt the user for a valid US mail address and return it as a string
//This version of the ask_mail_address function uses the ToSocketAddrs trait to validate the mail address entered by the user. If the mail address is not a valid address, an error message is returned as the result.
//The function also sanitizes the mail address by using the FromStr trait to convert the address to a string and taking the first address returned by ToSocketAddrs. This ensures that any unnecessary or potentially malicious elements of the address are removed before the address is used.
async fn ask_mail_address() -> Result<String, String> {
    println!("Please enter a valid US mail address:");
    let mut mail_address = String::new();
    // Read the user's input from stdin
    io::stdin().read_line(&mut mail_address).await.unwrap();
    // Trim leading and trailing whitespace
    mail_address = mail_address.trim().to_string();
    // Validate the mail address using the ToSocketAddrs trait
    let addr = mail_address.to_socket_addrs().map_err(|_| "Invalid mail address")?;
    // Sanitize the mail address by taking the first address returned by ToSocketAddrs
    let sanitized_mail_address = addr.next().unwrap().to_string();
    // Return the sanitized mail address as a result
    Ok(sanitized_mail_address)
}


// Asynchronously generate an ascending 8-digit number and return it as a u64
async fn gen_order_number() -> u64 {
    // Declare a static variable to store the current order number
    static mut ORDER_NUMBER: u64 = 0;
    // Increment the order number and return it
    unsafe {
        ORDER_NUMBER += 1;
        ORDER_NUMBER
    }
}
    // Define a form for collecting the user's mail address using the `Form` macro provided by Rocket
#[derive(FromForm)]
struct MailAddressForm {
    mail_address: String,
}
// Define a route for displaying the form for collecting the user's mail address
#[get("/mail_address_form")]
fn mail_address_form() -> Template {
    // Render the form template
    Template::render("mail_address_form", &MailAddressForm { mail_address: String::new() })
}



// Asynchronously make an HTTP POST request to the FWS API to redeem saffron tokens
async fn redeem_saffron(x: u64, client: &Client, mail_address: &str) -> Result<Response, reqwest::Error> {
    // Create an instance of the SaffronOrder struct with the specified number of tokens, the mail address entered by the user, and a unique order number
    let order = SaffronOrder {
        x,
               mail_address: mail_address.to_string(), // mail_address: ask_mail_address().await,
        order_number: gen_order_number().await,
    };

    // Set the placeholder AWS credentials and the URL for the FWS API
    let creds = "AWS_CREDS_PLACEHOLDER";
    let url = "https://fws.com/api/redeem_saffron";
    // Make the HTTP POST request with the specified header and JSON body, and return the response
    let res = client.post(url)
        .header("Authorization", creds)
        .json(&order)
        .send()
        .await;
       // Return the result of the request or an error message
    match res {
        Ok(response) => Ok(response),
        Err(e) => Err(e),
    }
}

// Define routes for the application
#[get("/")]
fn index() -> Template {
    let context = MailAddressForm { mail_address: "".to_string() };
    Template::render("index", &context)
}

#[post("/", data = "<form>")]
async fn redeem(form: Form<MailAddressForm>) -> Redirect {
    // Validate the mail address entered by the user
    let mail_address = form.mail_address.trim();
    if !mail_address.is_empty() {
        // Create an instance of the reqwest::Client type
        let client = Client::new();
        // Call the redeem_saffron function to make the HTTP POST request to the FWS API
        let res = redeem_saffron(10, &client, &mail_address).await;
        match res {
            Ok(_) => Redirect::to("/success"),
            Err(_) => Redirect::to("/error"),
        }
    } else {
        // Return an error if the mail address is empty
        Redirect::to("/error")
    }
}
    
#[get("/success")]
fn success() -> Template {
    Template::render("success", &())
}

#[get("/error")]
fn error() -> Template {
    Template::render("error", &())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize the Rocket application and start the server
    rocket::ignite()
        .mount("/", routes![index, redeem, success, error])
        .launch();
    Ok(())
}   
    
// Define the main function for the program
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create an instance of the reqwest::Client type
    let client = Client::new();
